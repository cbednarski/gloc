package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var reComment = regexp.MustCompile(`^\s*?\/\/.*$`)
var reWhitespace = regexp.MustCompile(`^\s*$`)
var reGobindata = regexp.MustCompile(`^// Code generated by go-bindata.$`)

func exitWithError(err error) {
	os.Stderr.WriteString(err.Error())
	os.Exit(1)
}

func parseArgs() (path string, vendor bool) {
	// This is a slightly janky but it lets us put -vendor before or after the
	// path and things will still work. Also path is optional so we'll infer if
	// the user doesn't supply one.
	args := os.Args[1:]
	skip := map[int]struct{}{}
	for key, val := range args {
		if val == "-vendor" {
			vendor = true
			skip[key] = struct{}{}
		}
	}

	for key, val := range args {
		if _, ok := skip[key]; ok {
			continue
		}
		// Add a / so it works with symlinks
		path = filepath.Clean(val) + "/"
	}

	if path == "" {
		var err error
		path, err = os.Getwd()
		if err != nil {
			exitWithError(err)
		}
	}

	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		exitWithError(err)
	}

	return path, vendor
}

func main() {
	files, code, tests, blanks, comments := 0, 0, 0, 0, 0
	var byteSize int64

	path, vendorFlag := parseArgs()

	err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
		name := info.Name()

		if info.IsDir() {
			if info.Name() == ".git" {
				return filepath.SkipDir
			}
			if info.Name() == "testdata" {
				return filepath.SkipDir
			}
			if info.Name() == "vendor" && !vendorFlag {
				fmt.Printf("- Skipping %s (use -vendor to include)\n", path)
				return filepath.SkipDir
			}
		}

		if filepath.Ext(name) != ".go" {
			return nil
		}

		file, err := os.Open(path)
		if err != nil {
			return err
		}
		defer file.Close()

		fileCode, fileTests, fileBlanks, fileComments := 0, 0, 0, 0
		scanner := bufio.NewScanner(file)

		for scanner.Scan() {
			line := scanner.Bytes()

			if reGobindata.Match(line) {
				fmt.Printf("- Skipping %s (go-bindata)\n", path)
				return nil
			}

			isComment := reComment.Match(line)
			isTest := strings.HasSuffix(name, "_test.go")

			if isTest {
				if !isComment && !reWhitespace.Match(line) {
					fileTests++
				}
			} else {
				if reWhitespace.Match(line) {
					fileBlanks++
				} else if isComment {
					fileComments++
				} else {
					fileCode++
				}
			}
		}

		if scanner.Err() != nil && scanner.Err() == bufio.ErrTooLong {
			fmt.Printf("- Skipping %s because of unusually long lines\n", path)
			return nil
		}
		files++
		byteSize += info.Size()
		code += fileCode
		tests += fileTests
		blanks += fileBlanks
		comments += fileComments

		return scanner.Err()
	})

	if err != nil {
		exitWithError(err)
	}

	if files == 0 {
		fmt.Printf("No Go source files found in %s\n", path)
	} else {
		total := code + comments + blanks
		totalF := float64(total)
		fmt.Printf("Source\t%8d\t%4.1f%%\n", code, float64(code)/totalF*100)
		fmt.Printf("Comment\t%8d\t%4.1f%%\n", comments, float64(comments)/totalF*100)
		fmt.Printf("Blank\t%8d\t%4.1f%%\t\n", blanks, float64(blanks)/totalF*100)
		fmt.Printf("Test\t%8d\t%4.1f per line of code\n", tests, float64(tests)/float64(code))
		fmt.Printf("Total\t%8d\t%d files\t%.1f KiB\n", total, files, float64(byteSize)/1024.0)
	}
}
